set.seed(1)
data_vec <- runif(20, -1, 1)
head(data_vec)
# 2.
set.seed(1)
one_boot <- sample(data_vec, size = length(data_vec), replace = TRUE)
mean(one_boot)
# 3.
set.seed(1)
B <- 10000
n <- length(data_vec)
# build bootstrap matrix (each column is a resample)
boot_matrix <- replicate(B, sample(data_vec, size = n, replace = TRUE))
boot_means <- colMeans(boot_matrix)
head(boot_means)
# 4.
hist(boot_means, main = "Bootstrap of Sample Means", xlab = "Sample Mean", breaks = 50)
mean(boot_means)
sd(boot_means)
# The bootstrap estimates look like a bell-shaped curve, centered around 0.11, with a spread of about 0.13.
# 5.
CI_percentile <- quantile(boot_means, probs = c(0.025, 0.975), type = 2)
CI_percentile
#6
sample.mean <- mean(data_vec)
sample.sd   <- sd(data_vec)
bootstrap.means <- colMeans(boot_matrix)
bootstrap.sds   <- apply(boot_matrix, 2, sd)
t.star <- (bootstrap.means - sample.mean) / (bootstrap.sds / sqrt(n))
head(t.star)
# 7.
t.quantiles <- quantile(t.star, probs = c(0.025, 0.975), type = 2)
CI.t <- sample.mean - rev(t.quantiles) * (sample.sd / sqrt(n))
CI.t
# 8
bootstrap_simple <- function(x, B = 10000, ci = "percentile", FUN = mean, seed = NULL) {
if (!is.null(seed)) set.seed(seed)
n <- length(x)
boots <- replicate(B, sample(x, size = n, replace = TRUE))
boot_stats <- apply(boots, 2, FUN)
point_est <- FUN(x)
boot_se <- sd(boot_stats, na.rm = TRUE)
if (ci == "percentile") {
ci_res <- quantile(boot_stats, probs = c(0.025, 0.975), type = 2, na.rm = TRUE)
} else if (ci == "t" && identical(FUN, mean)) {
boot_means_local <- boot_stats
boot_sds_local <- apply(boots, 2, sd)
t_stats <- (boot_means_local - point_est) / (boot_sds_local / sqrt(n))
t_q <- quantile(t_stats, probs = c(0.025, 0.975), type = 2, na.rm = TRUE)
ci_res <- point_est - rev(t_q) * (sd(x) / sqrt(n))
} else {
ci_res <- quantile(boot_stats, probs = c(0.025, 0.975), type = 2, na.rm = TRUE)
}
list(estimate = point_est, se = boot_se, CI = ci_res)
}
set.seed(1)
bootstrap_simple(data_vec, B = 10000, ci = "percentile", FUN = mean, seed = 1)
set.seed(1)
bootstrap_simple(data_vec, B = 10000, ci = "t", FUN = mean, seed = 1)
# 9a
set.seed(1)
res_sd <- bootstrap_simple(data_vec, B = 10000, ci = "percentile", FUN = sd, seed = 1)
res_sd
# 9b
set.seed(1)
res_med <- bootstrap_simple(data_vec, B = 10000, ci = "percentile", FUN = median, seed = 1)
res_med
# 9c
prop_lt_0.4 <- function(v) mean(v < 0.4)
set.seed(1)
res_prop <- bootstrap_simple(data_vec, B = 10000, ci = "percentile", FUN = prop_lt_0.4, seed = 1)
res_prop
# 9d
third_largest <- function(v) sort(v, decreasing = TRUE)[3]
set.seed(1)
res_third <- bootstrap_simple(data_vec, B = 10000, ci = "percentile", FUN = third_largest, seed = 1)
res_third
# 9e
bern_median_lt_0.4 <- function(v) as.numeric(median(v) < 0.4)
set.seed(1)
res_bern <- bootstrap_simple(data_vec, B = 10000, ci = "percentile", FUN = bern_median_lt_0.4, seed = 1)
res_bern
setwd("~/Stat/T-Test-R-package")
# In R console
devtools::clean_dll()  # Remove compiled code
unlink("man", recursive = TRUE)  # Remove old documentation
unlink("NAMESPACE")  # Remove old namespace
install.packages("roxygen2")
devtools::document()
devtools::build()
devtools::check()
devtools::document()
devtools::test()
devtools::document()
devtools::test()
library(oneMeanTest)
set.seed(123)
x <- rnorm(30, mean = 5, sd = 2)
result <- one_mean_test(x, mu0 = 5, alternative = "two.sided")
# Generate and view report
report <- format_ttest_report(result)
cat(report)
usethis::use_github_action("check-standard")
usethis::use_github_action("test-coverage")
usethis::use_github_action("pkgdown")
# Complete verification sequence
devtools::document()    # ✅ Generate documentation
devtools::test()        # ✅ Run all tests
devtools::check()       # ✅ R CMD check
devtools::build()       # ✅ Build package tarball
devtools::install()     # ✅ Install locally
# Verify everything works
library(oneMeanTest)
?one_mean_test
?format_ttest_report
example(one_mean_test)
devtools::document()
devtools::test()
devtools::check()
usethis::use_build_ignore("ttest_report.txt")
devtools::document()
devtools::document()
devtools::test()
devtools::check()
# 1. Re-document the package
devtools::document()
# 2. Test the new functions
library(oneMeanTest)
set.seed(123)
x <- rnorm(30, mean = 5, sd = 2)
result <- one_mean_test(x, mu0 = 5)
# Test console format
cat(report(result, format = "console"))
# Test markdown format
cat("\n\n=== MARKDOWN FORMAT ===\n\n")
cat(report(result, format = "markdown"))
# Test LaTeX format
cat("\n\n=== LATEX FORMAT ===\n\n")
cat(report(result, format = "latex"))
# 3. Run tests
devtools::test()
# 4. Final check
devtools::check()
usethis::use_mit_license("Agub,Reijel")
# Remove the test file
if (file.exists("ttest_report.txt")) {
file.remove("ttest_report.txt")
}
# Add to .Rbuildignore
usethis::use_build_ignore("ttest_report.txt")
# ============================================
# COMPLETE FIX SCRIPT
# ============================================
# 1. Fix LICENSE
usethis::use_mit_license("Your Name")
# 2. Clean up test artifacts
if (file.exists("ttest_report.txt")) {
file.remove("ttest_report.txt")
}
usethis::use_build_ignore("ttest_report.txt")
# 3. Update your .gitignore to prevent this in future
writeLines(c(
"*.txt",
"!LICENSE",
"!NEWS.txt"
), ".gitignore", useBytes = TRUE)
# 4. Re-document (this will pick up the @importFrom)
devtools::document()
# 5. Run tests
devtools::test()
# 6. Final check
devtools::check()
usethis::use_build_ignore("ttest_report.txt")
devtools::document()
devtools::check()
file.remove("ttest_report.txt")
usethis::use_build_ignore("ttest_report.txt")
devtools::document()
devtools::check()
file.remove("ttest_report.txt")
usethis::use_build_ignore("ttest_report.txt")
devtools::check()
library(covr)
coverage <- package_coverage()
print(coverage)
# Save all the new test files, then:
# Document
devtools::document()
# Run tests
devtools::test()
# Check coverage again
library(covr)
cov <- package_coverage()
# Document
devtools::document()
# Run all tests
devtools::test()
# Check coverage
library(covr)
cov <- package_coverage()
# Document and test
devtools::document()
devtools::test()
# Check coverage
library(covr)
cov <- package_coverage()
devtools::test()
# If all pass:
library(covr)
cov <- package_coverage()
print(cov)
percent_coverage(cov)
report(cov)
covr::report(cov)
pkgdown::build_site()
# Install/update pkgdown
install.packages("pkgdown")
install.packages("pkgdown")
usethis::use_pkgdown()
pkgdown::build_site()
# Load devtools
library(devtools)
# Clean and rebuild documentation
devtools::document()
# Check the package
devtools::check()
# Install the package locally
devtools::install()
# Load the package
devtools::load_all()
r
# Read the test file
test_file <- "tests/testthat/test-one_mean_test.R"
content <- readLines(test_file)
# Add tolerance to expect_equal calls
content <- gsub(
"expect_equal\\(ours\\$p\\.value, theirs\\$p\\.value\\)",
"expect_equal(ours$p.value, theirs$p.value, tolerance = 0.01)",
content
)
content <- gsub(
"expect_equal\\(unname\\(ours\\$conf\\.int\\), unname\\(theirs\\$conf\\.int\\)\\)",
"expect_equal(unname(ours$conf.int), unname(theirs$conf.int), tolerance = 0.01)",
content
)
# Write back
writeLines(content, test_file)
cat("Test file updated with tolerance values!\n")
devtools::document()
devtools::install()
devtools::test()
# Read the test file
file_path <- "tests/testthat/test-one_mean_test.R"
lines <- readLines(file_path)
# Fix line 26
lines[26] <- gsub(
"expect_equal\\(ours\\$p\\.value, theirs\\$p\\.value\\)",
"expect_equal(ours$p.value, theirs$p.value, tolerance = 0.001)",
lines[26]
)
# Fix line 29
lines[29] <- gsub(
"expect_equal\\(unname\\(ours\\$conf\\.int\\), unname\\(theirs\\$conf\\.int\\)\\)",
"expect_equal(unname(ours$conf.int), unname(theirs$conf.int), tolerance = 0.0001)",
lines[29]
)
# Fix line 58 (both occurrences in that test block)
lines[58] <- gsub(
"expect_equal\\(ours\\$p\\.value, theirs\\$p\\.value\\)",
"expect_equal(ours$p.value, theirs$p.value, tolerance = 0.00001)",
lines[58]
)
# Write back
writeLines(lines, file_path)
cat("Fixed! Now run: devtools::test()\n")
devtools::document()
devtools::install()
devtools::test()
# Read the file
file_path <- "tests/testthat/test-one_mean_test.R"
content <- readLines(file_path)
# Show the current lines that need fixing
cat("Line 26:", content[26], "\n")
cat("Line 29:", content[29], "\n")
cat("Line 58:", content[58], "\n\n")
# Fix line 26 - add tolerance for p-value
if (grepl("expect_equal\\(ours\\$p\\.value, theirs\\$p\\.value\\)", content[26])) {
content[26] <- "  expect_equal(ours$p.value, theirs$p.value, tolerance = 0.001)"
cat("✓ Fixed line 26\n")
}
# Fix line 29 - add tolerance for confidence interval
if (grepl("expect_equal\\(unname\\(ours\\$conf\\.int\\), unname\\(theirs\\$conf\\.int\\)\\)", content[29])) {
content[29] <- "  expect_equal(unname(ours$conf.int), unname(theirs$conf.int), tolerance = 0.0001)"
cat("✓ Fixed line 29\n")
}
# Fix line 58 - add tolerance for p-value
if (grepl("expect_equal\\(ours.*\\$p\\.value, theirs.*\\$p\\.value\\)", content[58])) {
content[58] <- gsub(
"expect_equal\\(([^)]+\\$p\\.value, [^)]+\\$p\\.value)\\)",
"expect_equal(\\1, tolerance = 0.00001)",
content[58]
)
cat("✓ Fixed line 58\n")
}
# Find and fix any other similar lines in that test
for (i in 55:65) {
if (grepl("expect_equal\\(ours.*\\$p\\.value, theirs.*\\$p\\.value\\)$", content[i])) {
content[i] <- gsub(
"expect_equal\\(([^)]+\\$p\\.value, [^)]+\\$p\\.value)\\)$",
"expect_equal(\\1, tolerance = 0.00001)",
content[i]
)
cat("✓ Fixed line", i, "\n")
}
}
# Save the file
writeLines(content, file_path)
cat("\n✓ File updated! Now run: devtools::test()\n")
devtools::document()
devtools::install()
devtools::test()
devtools::document()
devtools::install()
devtools::test()
devtools::document()
devtools::install()
devtools::test()
devtools::document()
devtools::install()
devtools::test()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
# Basic coverage report
cov <- package_coverage()
cov
# View coverage percentage
percent_coverage(cov)
# Interactive HTML report (opens in browser)
report(cov)
devtools::check()
devtools::check()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
library(covr)
cov <- package_coverage()
percent_coverage(cov)
report(cov)
cov
library(covr)
cov <- package_coverage()
percent_coverage(cov)
# Use covr's report function explicitly
covr::report(cov)
devtools::test()
devtools::test()
# Basic coverage report
cov <- package_coverage()
cov
# View coverage percentage
percent_coverage(cov)
# Interactive HTML report (opens in browser)
report(cov)
devtools::test()
devtools::check()
devtools::document()
devtools::test()
devtools::check()
devtools::document()
devtools::test()
devtools::check()
devtools::document()
devtools::test()
devtools::check()
# Basic coverage report
cov <- package_coverage()
cov
# View coverage percentage
percent_coverage(cov)
# Interactive HTML report (opens in browser)
report(cov)
# Add the tests above, then:
devtools::test_coverage()
devtools::test()
devtools::document()
devtools::test()
# Fix test-03-input-validation.R (replace last test_that block)
cat('
test_that("utils helper functions work", {
result <- one_mean_test(rnorm(10))
expect_true(inherits(result, "oneMeanTest"))
expect_false(any(class(list()) == "oneMeanTest"))
expect_equal(nrow(result$sample.stats), 1)
})
', file = "tests/testthat/test-03-input-validation.R", append = TRUE)
# Fix test-10-plotting.R (replace last two test_that blocks)
cat('
test_that("plot functions handle edge cases", {
x <- rnorm(5)
result <- one_mean_test(x, mu0 = 0, check_assumptions = FALSE)
expect_silent(plot(result, type = "diagnostic"))
expect_silent(plot(result, type = "ci"))
})
test_that("all plot types work", {
x <- rnorm(30)
result <- one_mean_test(x, mu0 = 0)
expect_silent(plot(result))
expect_silent(plot(result, type = "distribution"))
expect_silent(plot(result, type = "ci"))
expect_silent(plot(result, type = "diagnostic"))
})
', file = "tests/testthat/test-10-plotting.R", append = TRUE)
# Fix test-11-power.R (replace all failing test_that blocks)
cat('
test_that("power_t_test handles edge cases", {
expect_equal(power_t_test(n = 10, delta = 0, sd = 1, alpha = 0.05), 0.05, tolerance = 0.01)
expect_error(power_t_test(n = 1, delta = 1, sd = 1, alpha = 0.05), "at least 2")
expect_error(power_t_test(n = -1, delta = 1, sd = 1, alpha = 0.05), "at least 2")
})
test_that("power_t_test one-sided vs two-sided", {
set.seed(123)
power_two <- power_t_test(30, 1, 2, 0.05, alternative = "two.sided")
power_greater <- power_t_test(30, 1, 2, 0.05, alternative = "greater")
expect_true(power_greater > power_two)
})
test_that("power functions cover all branches", {
set.seed(123)
expect_equal(power_t_test(30, 0, 1, 0.05, alternative = "two.sided"), 0.05, tolerance = 0.01)
expect_gt(power_t_test(100, 5, 10, 0.05, alternative = "two.sided"), 0.8)
expect_error(power_t_test(n = 1, delta = 1, sd = 1, alpha = 0.05), "at least 2")
expect_error(power_t_test(n = 30, delta = 1, sd = 0, alpha = 0.05), "positive")
})
', file = "tests/testthat/test-11-power.R", append = TRUE)
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
# Add the tests above, then:
devtools::test_coverage()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
# Add the tests above, then:
devtools::test_coverage()
# Basic coverage report
cov <- package_coverage()
cov
# View coverage percentage
percent_coverage(cov)
library(readxl)
sample_data <- read_excel("D:/Downloads/sample_data.xlsx")
View(sample_data)
result<-oneMeanTest(
x = sample_data[["Earnings"]],
mu = 100,
sigma.x = 15,
conf.level = 0.95,
alternative = "greater",
mu0 = 75
)
library(oneMeanTest)
result<-oneMeanTest(
x = sample_data[["Earnings"]],
mu = 100,
sigma.x = 15,
conf.level = 0.95,
alternative = "greater",
mu0 = 75
)
result <- oneMeanTTest(x = "Earnings", mu = 75, ha = "greater", alpha = 0.05, data = sampledata)
result <- oneMeanTest(x = "Earnings", mu = 75, ha = "greater", alpha = 0.05, data = sampledata)
devtools::load_all()
result <- oneMeanTest(x = "Earnings", mu = 75, ha = "greater", alpha = 0.05, data = sampledata)
result <- one_mean_test(x = "Earnings", mu = 75, ha = "greater", alpha = 0.05, data = sampledata)
devtools::test()
result <- one_mean_test(x = "Earnings", mu = 75, ha = "greater", alpha = 0.05, data = sampledata)
result <- one_mean_test(x = "Earnings", mu = 75, alternative = "greater", alpha = 0.05, data = sampledata)
result <- one_mean_test(x = sample_data[["Earnings"]], mu = 75, alternative = "greater", alpha = 0.05, )
print(result)
result <- one_mean_test(x = sample_data[["Earnings"]], mu = 75, alternative = "greater", alpha = 0.05, )
print(result)
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
devtools::test()
result <- one_mean_test(x = sample_data[["Earnings"]], mu = 75, alternative = "greater", alpha = 0.05, )
print(result)
plot(result, type = "all")
devtools::document()
devtools::build()
install.packages("d:/Documents/Stat/T-Test-R-package_0.1.0.tar.gz", repos = NULL)
install.packages("d:/Documents/Stat/oneMeanTest_0.1.0.tar.gz", repos = NULL)
